<template>
  <div>
    <div class="mb-2 space-x-4">
      <label><input type="checkbox" v-model="enabledSimpleColors" /> Show Simple Colors</label>
      <label><input type="checkbox" v-model="enabledTailwindColors" /> Show Tailwind Colors</label>
      <label><input type="checkbox" v-model="enabledCities" /> Show Cities</label>
    </div>
    <div ref="container" class="relative w-[800px] h-[600px] border">
      <canvas ref="canvas" width="800" height="600" class="absolute top-0 left-0"></canvas>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue';
import tailwindColors from 'tailwindcss/colors';
import { colorToHCL } from '@/utils/color';

const canvas = ref<HTMLCanvasElement | null>(null);
const container = ref<HTMLDivElement | null>(null);

const enabledCities = ref(true);
const enabledSimpleColors = ref(true);
const enabledTailwindColors = ref(false);

interface Point {
  color: string;
  name: string;
  H: number;
  C: number;
  L: number;
  type: 'tailwind' | 'simple' | 'city';
}

const points: Point[] = [];

function addColor(name: string, color: string, type: Point['type']) {
  const { H, C, L } = colorToHCL(color);
  points.push({ name, color, H, C, L, type });
}

// Tailwind 색상
for (const [name, colorObj] of Object.entries(tailwindColors)) {
  if (typeof colorObj === 'object' && colorObj !== null) {
    for (const step of ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950']) {
      const val = colorObj[step as keyof typeof colorObj];
      if (typeof val === 'string') addColor(`${name}-${step}`, val, 'tailwind');
    }
  }
}

// Simple 색상
const simpleColors: Record<string, string> = {
  black: '#000000', white: '#ffffff', red: '#ff0000', green: '#00ff00', blue: '#0000ff'
};
for (const [name, val] of Object.entries(simpleColors)) {
  addColor(name, val, 'simple');
}

// Cities
const cityPoints = [
  { name: 'North Pole', lat: 90, lon: 0 },
  { name: 'South Pole', lat: -90, lon: 0 },
  { name: 'Seoul', lat: 37.5665, lon: 126.9780 },
  { name: 'Tokyo', lat: 35.6895, lon: 139.6917 },
  { name: 'London', lat: 51.5074, lon: -0.1278 },
  { name: 'Sydney', lat: -33.8688, lon: 151.2093 },
  { name: 'Cape Town', lat: -33.9249, lon: 18.4241 },
  { name: 'Singapore', lat: 1.3521, lon: 103.8198 },
  { name: 'Honolulu', lat: 21.3069, lon: -157.8583 },
  { name: 'Buenos Aires', lat: -34.6037, lon: -58.3816 },
];
cityPoints.forEach(({ name, lat, lon }) => {
  points.push({
    name,
    color: '#ffffff',
    H: lon % 360,
    C: 0.5,
    L: (lat + 90) / 180,
    type: 'city',
  });
});

let zoom = 1;
const offsetX = 0;
let hueOffset = 0;
let rotateXZ = Math.PI / 6;
const tiltYZ = 23.5 * Math.PI / 180;
let isDragging = false;
let lastX = 0, lastY = 0;

function oklchToSpherical3D(H: number, C: number, L: number) {
  const lat = 90 - L * 180;
  const lon = H;
  const latRad = (lat * Math.PI) / 180;
  const lonRad = (lon * Math.PI) / 180;

  const axialDistance = (0.5 - Math.abs(L - 0.5)) * 10;
  const r = C * axialDistance;

  const x = r * Math.cos(lonRad) * Math.cos(latRad);
  const y = Math.sin(latRad);
  const z = r * Math.sin(lonRad) * Math.cos(latRad);

  return { x, y, z };
}

function projectSpherical3D(H: number, C: number, L: number) {
  const { x, y, z } = oklchToSpherical3D(H + hueOffset, C, L);

  const x1 = x * Math.cos(rotateXZ) + z * Math.sin(rotateXZ);
  const z1 = -x * Math.sin(rotateXZ) + z * Math.cos(rotateXZ);

  const y1 = y * Math.cos(tiltYZ) + z1 * Math.sin(tiltYZ);
  const z2 = -y * Math.sin(tiltYZ) + z1 * Math.cos(tiltYZ);

  const scale = 300;
  const centerX = 400;
  const centerY = 300;

  return {
    x: centerX + x1 * scale * zoom + offsetX,
    y: centerY + y1 * scale * zoom,
    z: z2,
    scale: 0.8 + (1 - z2) * 0.5,
  };
}

function render(ctx: CanvasRenderingContext2D) {
  ctx.clearRect(0, 0, 800, 600);

  const projected = points.map(p => ({
    ...projectSpherical3D(p.H, p.C, p.L),
    p,
  })).sort((a, b) => a.z - b.z);

  for (const { x, y, scale, p } of projected) {
    if ((p.type === 'tailwind' && !enabledTailwindColors.value) ||
      (p.type === 'simple' && !enabledSimpleColors.value) ||
      (p.type === 'city' && !enabledCities.value)) continue;

    const radius = 4 * scale;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'white';
    ctx.font = `${10 * scale}px sans-serif`;
    ctx.fillText(p.name, x + radius + 2, y + 4);
  }
}

onMounted(() => {
  const ctx = canvas.value!.getContext('2d')!;
  const rerender = () => render(ctx);
  rerender();

  container.value!.addEventListener('mousedown', e => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  window.addEventListener('mouseup', () => isDragging = false);
  window.addEventListener('mousemove', e => {
    if (!isDragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    hueOffset -= dx * 0.5;
    rotateXZ += dy * 0.005;
    rotateXZ = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotateXZ));
    lastX = e.clientX;
    lastY = e.clientY;
    rerender();
  });
  container.value!.addEventListener('wheel', e => {
    e.preventDefault();
    zoom *= e.deltaY > 0 ? 0.9 : 1.1;
    zoom = Math.max(0.2, Math.min(zoom, 5));
    rerender();
  }, { passive: false });

  [enabledCities, enabledSimpleColors, enabledTailwindColors].forEach(flag => {
    watch(flag, rerender);
  });
});
</script>

<style scoped>
canvas {
  background: black;
}
</style>
